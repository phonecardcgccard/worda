<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Match - 中英文单词配对游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .card {
            animation: fadeIn 0.3s ease-out;
            transition: all 0.2s;
            perspective: 1000px;
        }
        
        .card-inner {
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        
        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        
        .card-front, .card-back {
            backface-visibility: hidden;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .card-back {
            transform: rotateY(180deg);
        }
        
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .selected {
            transform: scale(0.95);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        
        .matched {
            animation: pulse 0.5s;
            opacity: 0.6;
            transform: scale(0.98);
        }
        
        .wrong {
            animation: shake 0.4s;
        }
        
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        .card-content {
            word-break: break-word;
            padding: 0.5rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-indigo-800 mb-2">Word Match</h1>
            <p class="text-lg text-indigo-600">中英文单词配对游戏</p>
        </header>

        <div class="max-w-6xl mx-auto bg-white rounded-xl shadow-lg overflow-hidden">
            <!-- Game Controls -->
            <div class="bg-indigo-700 text-white p-4 flex flex-col md:flex-row justify-between items-center">
                <div class="flex items-center space-x-4 mb-4 md:mb-0">
                    <button id="newGameBtn" class="bg-white text-indigo-700 px-4 py-2 rounded-lg font-medium hover:bg-indigo-100 transition">
                        <i class="fas fa-redo mr-2"></i>新游戏
                    </button>
                    <div class="flex items-center">
                        <label class="mr-2">难度:</label>
                        <select id="difficulty" class="bg-indigo-600 text-white border border-indigo-500 rounded px-2 py-1">
                            <option value="simple">简单</option>
                            <option value="complex">复杂</option>
                            <option value="custom">自定义</option>
                        </select>
                    </div>
                </div>
                
                <div class="flex items-center space-x-6">
                    <div class="text-center">
                        <div class="text-sm opacity-80">得分</div>
                        <div id="score" class="text-2xl font-bold">0</div>
                    </div>
                    <div class="text-center">
                        <div class="text-sm opacity-80">剩余</div>
                        <div id="remaining" class="text-2xl font-bold">40</div>
                    </div>
                    <div class="text-center">
                        <div class="text-sm opacity-80">时间</div>
                        <div id="timer" class="text-2xl font-bold">00:00</div>
                    </div>
                </div>
            </div>
            
            <!-- Custom Words Input (hidden by default) -->
            <div id="customWordsContainer" class="hidden p-4 bg-gray-100">
                <div class="mb-4">
                    <label class="block text-gray-700 mb-2">输入自定义单词对 (每行一个, 格式: 英文=中文)</label>
                    <textarea id="customWordsInput" class="w-full p-2 border rounded" rows="5" placeholder="apple=苹果&#10;book=书&#10;cat=猫"></textarea>
                </div>
                <button id="saveCustomWords" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                    保存自定义单词
                </button>
            </div>
            
            <!-- Progress Bar -->
            <div class="h-2 bg-gray-200">
                <div id="progressBar" class="h-full bg-green-500 progress-bar" style="width: 0%"></div>
            </div>
            
            <!-- Game Board -->
            <div id="gameBoard" class="p-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 min-h-[500px]">
                <!-- Cards will be generated here -->
            </div>
            
            <!-- Game Messages -->
            <div id="message" class="hidden fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-10">
                <div class="bg-white p-8 rounded-xl text-center max-w-md mx-4">
                    <h2 id="messageTitle" class="text-3xl font-bold mb-4"></h2>
                    <p id="messageText" class="text-lg mb-6"></p>
                    <div id="messageStats" class="mb-4 text-left"></div>
                    <button id="messageBtn" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700 transition">
                        继续
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game data with more words
        const wordPairs = {
            simple: [
                { english: "apple", chinese: "苹果" },
                { english: "book", chinese: "书" },
                { english: "cat", chinese: "猫" },
                { english: "dog", chinese: "狗" },
                { english: "egg", chinese: "鸡蛋" },
                { english: "fish", chinese: "鱼" },
                { english: "girl", chinese: "女孩" },
                { english: "house", chinese: "房子" },
                { english: "ice", chinese: "冰" },
                { english: "juice", chinese: "果汁" },
                { english: "king", chinese: "国王" },
                { english: "love", chinese: "爱" },
                { english: "moon", chinese: "月亮" },
                { english: "name", chinese: "名字" },
                { english: "open", chinese: "打开" },
                { english: "pen", chinese: "钢笔" },
                { english: "queen", chinese: "女王" },
                { english: "red", chinese: "红色" },
                { english: "sun", chinese: "太阳" },
                { english: "tree", chinese: "树" },
                { english: "water", chinese: "水" },
                { english: "xylophone", chinese: "木琴" },
                { english: "yellow", chinese: "黄色" },
                { english: "zoo", chinese: "动物园" }
            ],
            complex: [
                { english: "abundance", chinese: "丰富" },
                { english: "benevolent", chinese: "仁慈的" },
                { english: "consequence", chinese: "后果" },
                { english: "diligent", chinese: "勤奋的" },
                { english: "eloquent", chinese: "雄辩的" },
                { english: "flourish", chinese: "繁荣" },
                { english: "gregarious", chinese: "社交的" },
                { english: "hierarchy", chinese: "等级制度" },
                { english: "impeccable", chinese: "无瑕疵的" },
                { english: "juxtaposition", chinese: "并列" },
                { english: "kaleidoscope", chinese: "万花筒" },
                { english: "luminous", chinese: "发光的" },
                { english: "meticulous", chinese: "一丝不苟的" },
                { english: "nostalgia", chinese: "怀旧" },
                { english: "obfuscate", chinese: "使困惑" },
                { english: "paradox", chinese: "悖论" },
                { english: "quintessential", chinese: "典型的" },
                { english: "resilient", chinese: "有弹性的" },
                { english: "serendipity", chinese: "意外发现" },
                { english: "trepidation", chinese: "恐惧" },
                { english: "ubiquitous", chinese: "普遍存在的" },
                { english: "voracious", chinese: "贪婪的" },
                { english: "wanderlust", chinese: "旅行癖" },
                { english: "xenophobia", chinese: "仇外心理" },
                { english: "yonder", chinese: "那边的" },
                { english: "zealot", chinese: "狂热者" }
            ],
            custom: []
        };

        // Game state
        const gameState = {
            selectedCards: [],
            matchedPairs: [],
            score: 0,
            remainingPairs: 0,
            timer: 0,
            timerInterval: null,
            currentDifficulty: 'simple',
            firstCard: null,
            secondCard: null,
            canClick: true,
            gameStartTime: null,
            moves: 0,
            wordCount: 20 // Default word count
        };

        // DOM elements
        const elements = {
            gameBoard: document.getElementById('gameBoard'),
            scoreElement: document.getElementById('score'),
            remainingElement: document.getElementById('remaining'),
            timerElement: document.getElementById('timer'),
            newGameBtn: document.getElementById('newGameBtn'),
            difficultySelect: document.getElementById('difficulty'),
            progressBar: document.getElementById('progressBar'),
            messageElement: document.getElementById('message'),
            messageTitle: document.getElementById('messageTitle'),
            messageText: document.getElementById('messageText'),
            messageStats: document.getElementById('messageStats'),
            messageBtn: document.getElementById('messageBtn'),
            customWordsContainer: document.getElementById('customWordsContainer'),
            customWordsInput: document.getElementById('customWordsInput'),
            saveCustomWords: document.getElementById('saveCustomWords')
        };

        // Initialize game
        function initGame() {
            // Reset game state
            Object.assign(gameState, {
                selectedCards: [],
                matchedPairs: [],
                score: 0,
                remainingPairs: gameState.wordCount,
                timer: 0,
                firstCard: null,
                secondCard: null,
                canClick: true,
                gameStartTime: null,
                moves: 0
            });

            // Update UI
            elements.scoreElement.textContent = gameState.score;
            elements.remainingElement.textContent = gameState.remainingPairs * 2;
            updateTimerDisplay();
            elements.progressBar.style.width = '0%';

            // Clear game board
            elements.gameBoard.innerHTML = '';

            // Start timer
            startTimer();

            // Prepare cards
            prepareCards();
        }

        // Prepare cards for the game
        function prepareCards() {
            // Get words based on difficulty
            const words = [...wordPairs[gameState.currentDifficulty]];
            
            // Select random words based on wordCount
            const selectedWords = shuffleArray(words).slice(0, gameState.wordCount);
            
            // Duplicate and shuffle words to create pairs
            let cards = [];
            selectedWords.forEach(word => {
                cards.push({ 
                    type: 'english', 
                    content: word.english, 
                    pairId: word.english,
                    flipped: false
                });
                cards.push({ 
                    type: 'chinese', 
                    content: word.chinese, 
                    pairId: word.english,
                    flipped: false
                });
            });

            // Shuffle cards
            cards = shuffleArray(cards);

            // Create card elements
            cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = `card bg-white rounded-lg shadow-md p-1 cursor-pointer h-24 relative`;
                cardElement.dataset.index = index;
                cardElement.dataset.pairId = card.pairId;
                cardElement.dataset.type = card.type;
                
                cardElement.innerHTML = `
                    <div class="card-inner w-full h-full">
                        <div class="card-front bg-indigo-100 rounded-lg flex items-center justify-center">
                            <div class="card-content text-indigo-800 font-bold">?</div>
                        </div>
                        <div class="card-back ${card.type === 'english' ? 'bg-blue-100 text-blue-800' : 'bg-red-100 text-red-800'} rounded-lg">
                            <div class="card-content font-medium">${card.content}</div>
                        </div>
                    </div>
                `;
                
                cardElement.addEventListener('click', () => handleCardClick(cardElement));
                elements.gameBoard.appendChild(cardElement);
            });
        }

        // Handle card click
        function handleCardClick(cardElement) {
            // If we can't click or card is already matched or selected, return
            if (!gameState.canClick || 
                cardElement.classList.contains('matched') || 
                gameState.selectedCards.includes(cardElement) ||
                cardElement.classList.contains('flipped')) {
                return;
            }

            // Flip the card
            cardElement.classList.add('flipped');
            
            // Record game start time on first move
            if (gameState.moves === 0) {
                gameState.gameStartTime = performance.now();
            }
            gameState.moves++;

            // If it's the first card selected
            if (gameState.selectedCards.length === 0) {
                gameState.firstCard = cardElement;
                gameState.selectedCards.push(cardElement);
            } 
            // If it's the second card selected
            else if (gameState.selectedCards.length === 1 && !gameState.selectedCards.includes(cardElement)) {
                gameState.secondCard = cardElement;
                gameState.selectedCards.push(cardElement);
                gameState.canClick = false;
                
                // Check if they match
                setTimeout(() => checkForMatch(), 500);
            }
        }

        // Check if selected cards match
        function checkForMatch() {
            const [firstCard, secondCard] = gameState.selectedCards;
            
            // If they match
            if (firstCard.dataset.pairId === secondCard.dataset.pairId && 
                firstCard.dataset.type !== secondCard.dataset.type) {
                
                // Add matched class
                firstCard.classList.add('matched');
                secondCard.classList.add('matched');
                
                // Update game state
                gameState.matchedPairs.push(firstCard.dataset.pairId);
                gameState.score += 10;
                gameState.remainingPairs--;
                
                // Update UI
                elements.scoreElement.textContent = gameState.score;
                elements.remainingElement.textContent = gameState.remainingPairs * 2;
                elements.progressBar.style.width = `${((gameState.wordCount * 2 - (gameState.remainingPairs * 2)) / (gameState.wordCount * 2)) * 100}%`;
                
                // Check if game is over
                if (gameState.remainingPairs === 0) {
                    endGame(true);
                }
            } 
            // If they don't match
            else {
                // Flip cards back
                setTimeout(() => {
                    firstCard.classList.remove('flipped');
                    secondCard.classList.remove('flipped');
                    firstCard.classList.add('wrong');
                    secondCard.classList.add('wrong');
                    
                    setTimeout(() => {
                        firstCard.classList.remove('wrong');
                        secondCard.classList.remove('wrong');
                    }, 500);
                }, 500);
                
                // Penalty for wrong match
                gameState.score = Math.max(0, gameState.score - 2);
                elements.scoreElement.textContent = gameState.score;
            }
            
            // Reset selection
            gameState.selectedCards = [];
            gameState.firstCard = null;
            gameState.secondCard = null;
            gameState.canClick = true;
        }

        // Start timer
        function startTimer() {
            clearInterval(gameState.timerInterval);
            gameState.timer = 0;
            gameState.timerInterval = setInterval(() => {
                gameState.timer++;
                updateTimerDisplay();
            }, 1000);
        }

        // Update timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timer / 60);
            const seconds = gameState.timer % 60;
            elements.timerElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // End game
        function endGame(isWin) {
            clearInterval(gameState.timerInterval);
            
            const endTime = performance.now();
            const timeTaken = gameState.gameStartTime ? ((endTime - gameState.gameStartTime) / 1000).toFixed(1) : 0;
            
            if (isWin) {
                showMessage(
                    '恭喜!', 
                    `你成功配对了所有单词!`,
                    'fa-trophy',
                    `得分: ${gameState.score}<br>
                     用时: ${formatTime(gameState.timer)}<br>
                     移动次数: ${gameState.moves}<br>
                     准确率: ${Math.round((gameState.wordCount / gameState.moves) * 100)}%`
                );
            } else {
                showMessage(
                    '游戏结束', 
                    `你配对了 ${gameState.wordCount - gameState.remainingPairs} 对单词`,
                    'fa-redo',
                    `得分: ${gameState.score}<br>
                     用时: ${formatTime(gameState.timer)}<br>
                     移动次数: ${gameState.moves}`
                );
            }
        }

        // Show message
        function showMessage(title, text, iconClass, stats = '') {
            elements.messageTitle.innerHTML = `<i class="fas ${iconClass} mr-2"></i>${title}`;
            elements.messageText.innerHTML = text;
            elements.messageStats.innerHTML = stats;
            elements.messageElement.classList.remove('hidden');
        }

        // Format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}分${secs}秒`;
        }

        // Utility function to shuffle array
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Handle custom words
        function handleCustomWords() {
            const input = elements.customWordsInput.value.trim();
            if (!input) return;
            
            const lines = input.split('\n');
            wordPairs.custom = [];
            
            lines.forEach(line => {
                const parts = line.split('=');
                if (parts.length === 2) {
                    wordPairs.custom.push({
                        english: parts[0].trim(),
                        chinese: parts[1].trim()
                    });
                }
            });
            
            if (wordPairs.custom.length > 0) {
                gameState.wordCount = Math.min(20, wordPairs.custom.length);
                initGame();
                elements.customWordsContainer.classList.add('hidden');
            }
        }

        // Event listeners
        elements.newGameBtn.addEventListener('click', initGame);
        elements.messageBtn.addEventListener('click', () => {
            elements.messageElement.classList.add('hidden');
        });
        elements.difficultySelect.addEventListener('change', (e) => {
            if (e.target.value === 'custom') {
                elements.customWordsContainer.classList.remove('hidden');
            } else {
                elements.customWordsContainer.classList.add('hidden');
                gameState.currentDifficulty = e.target.value;
                gameState.wordCount = 20;
                initGame();
            }
        });
        elements.saveCustomWords.addEventListener('click', handleCustomWords);

        // Start the game
        initGame();
    </script>
</body>
</html>


